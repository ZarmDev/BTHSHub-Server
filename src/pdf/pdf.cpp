// This file was mostly generated by AI. The podofo documentation is too
// difficult to understand so I resorted to completely letting AI handle text
// parsing. However, I completely wrote the parseSchedule function myself.

#include "global.h"
#include "utils.h"
#include <array>
#include <cctype>
#include <iostream>
#include <nlohmann/json.hpp>
#include <podofo/main/PdfDeclarations.h>
#include <podofo/podofo.h>
#include <span>

using namespace PoDoFo;
using namespace std;

namespace PDF {
// Parse PDF content stream to extract text
string parseContentStream(const string &content) {
  string text = "";
  size_t pos = 0;
  bool inTextObject = false;
  float lastYPosition = -1;
  float lastXPosition = -1;
  float expectedCellWidth = 160.0; // Adjust based on your PDF's cell width

  while (pos < content.length()) {
    // Skip whitespace
    while (pos < content.length() && isspace(content[pos])) {
      pos++;
    }

    if (pos >= content.length())
      break;

    // Check for BT/ET
    if (pos + 1 < content.length() && content.substr(pos, 2) == "BT" &&
        (pos + 2 >= content.length() || isspace(content[pos + 2]))) {
      inTextObject = true;
      pos += 2;
      continue;
    }

    if (pos + 1 < content.length() && content.substr(pos, 2) == "ET" &&
        (pos + 2 >= content.length() || isspace(content[pos + 2]))) {
      inTextObject = false;
      pos += 2;
      continue;
    }

    if (inTextObject) {
      if (pos + 1 < content.length() &&
          (content.substr(pos, 2) == "Td" || content.substr(pos, 2) == "TD")) {

        // Look backwards for TWO numbers before Td/TD
        // PDF format is typically: "x y Td"
        size_t searchEnd = pos;
        while (searchEnd > 0 && isspace(content[searchEnd - 1]))
          searchEnd--;

        // Find the end of the second number (Y coordinate)
        size_t yEnd = searchEnd;
        while (yEnd > 0 &&
               (isdigit(content[yEnd - 1]) || content[yEnd - 1] == '.' ||
                content[yEnd - 1] == '-')) {
          yEnd--;
        }

        // Skip whitespace between numbers
        size_t yStart = yEnd;
        while (yStart > 0 && isspace(content[yStart - 1]))
          yStart--;

        // Find the end of the first number (X coordinate)
        size_t xEnd = yStart;
        while (xEnd > 0 &&
               (isdigit(content[xEnd - 1]) || content[xEnd - 1] == '.' ||
                content[xEnd - 1] == '-')) {
          xEnd--;
        }

        // Extract both coordinates
        string xStr = content.substr(xEnd, yStart - xEnd);
        string yStr = content.substr(yEnd, searchEnd - yEnd);

        // cout << "Trying to parse X: '" << xStr << "' Y: '" << yStr << "'"
        //      << endl;

        try {
          float x = stof(xStr);
          float y = stof(yStr);

          // cout << "Parsed coordinates: " << x << " " << y << endl;

          // Calculate gap from last position
          if (lastXPosition != -1) {
            float xGap = abs(x - lastXPosition);
            // cout << "X Gap: " << xGap << endl;
            if (xGap > expectedCellWidth) {
              text += "<<EMPTY_CELL>> ";
            }
          }
          lastXPosition = x;
          lastYPosition = y;
        } catch (const invalid_argument &e) {
          cout << "Failed to parse coordinates" << endl;
        }

        pos += 2;
        continue;
      }

      // ... your existing text extraction code ...

      // Look for text strings in parentheses
      if (content[pos] == '(') {
        size_t endPos = pos + 1;
        int parenCount = 1;

        while (endPos < content.length() && parenCount > 0) {
          if (content[endPos] == '(')
            parenCount++;
          else if (content[endPos] == ')')
            parenCount--;
          endPos++;
        }

        if (parenCount == 0) {
          string textContent = content.substr(pos + 1, endPos - pos - 2);
          text += textContent + " ";
        }
        pos = endPos;
        continue;
      }

      // Look for array notation with TJ operator
      if (content[pos] == '[') {
        size_t endPos = pos + 1;
        int bracketCount = 1;

        while (endPos < content.length() && bracketCount > 0) {
          if (content[endPos] == '[')
            bracketCount++;
          else if (content[endPos] == ']')
            bracketCount--;
          endPos++;
        }

        if (bracketCount == 0) {
          string arrayContent = content.substr(pos + 1, endPos - pos - 2);

          size_t arrayPos = 0;
          while (arrayPos < arrayContent.length()) {
            size_t parenStart = arrayContent.find('(', arrayPos);
            if (parenStart == string::npos)
              break;

            size_t parenEnd = arrayContent.find(')', parenStart);
            if (parenEnd == string::npos)
              break;

            string textContent =
                arrayContent.substr(parenStart + 1, parenEnd - parenStart - 1);
            text += textContent + " ";

            arrayPos = parenEnd + 1;
          }
        }
        pos = endPos;
        continue;
      }

      // Look for hex strings
      if (content[pos] == '<') {
        size_t endPos = content.find('>', pos);
        if (endPos != string::npos) {
          pos = endPos + 1;
          continue;
        }
      }
    }

    // Move forward by one character to avoid infinite loops
    pos++;
  }

  return text;
}

string extractTextFromPage(const PdfPage &page) {
  string extractedText = "";

  try {
    // Get the contents as a stream
    const PdfContents *contents = page.GetContents();
    if (contents == nullptr) {
      return "";
    }

    // Get the underlying PdfObject from PdfContents
    const PdfObject &contentsObj = contents->GetObject();

    if (contentsObj.IsArray()) {
      // Multiple content streams
      const PdfArray &contentsArray = contentsObj.GetArray();
      for (size_t i = 0; i < contentsArray.GetSize(); ++i) {
        const PdfObject &streamObj = contentsArray[i];
        if (streamObj.IsReference()) {
          const PdfObject *resolvedObj =
              page.GetDocument().GetObjects().GetObject(
                  streamObj.GetReference());
          if (resolvedObj && resolvedObj->HasStream()) {
            charbuff buffer;
            resolvedObj->GetStream()->CopyTo(buffer);
            string content(buffer.data(), buffer.size());
            extractedText += parseContentStream(content);
          }
        }
      }
    } else if (contentsObj.HasStream()) {
      // Single content stream - check the PdfObject, not PdfContents
      charbuff buffer;
      contentsObj.GetStream()->CopyTo(buffer);
      string content(buffer.data(), buffer.size());
      extractedText += parseContentStream(content);
    }

  } catch (const exception &e) {
    cout << "Error extracting text from page: " << e.what() << endl;
  }

  return extractedText;
}

string getPDFText(const vector<unsigned char>& pdfData) {
  try {

    PdfMemDocument doc;
    // doc.Load(fileLocation);
    // Create a span/view over the vector data with proper type conversion
    std::span<const char> buffer(
        reinterpret_cast<const char*>(pdfData.data()), 
        pdfData.size()
    );
    
    // Now pass the properly typed span to LoadFromBuffer
    doc.LoadFromBuffer(buffer);

    const PdfPageCollection &pages = doc.GetPages();
    std::cout << "PDF loaded successfully. Pages: " << pages.GetCount()
              << std::endl;

    string extractedText = "";

    for (unsigned int i = 0; i < pages.GetCount(); ++i) {
      const PdfPage &page = pages.GetPageAt(i);

      if (page.GetContents() != nullptr) {
        std::cout << "Processing page " << (i + 1) << std::endl;
        string pageText = extractTextFromPage(page);

        if (!pageText.empty()) {
          extractedText += "=== Page " + to_string(i + 1) + " ===\n";
          extractedText += pageText + "\n\n";
        }
      }
    }

    // writeToFile("test.txt", extractedText);
    // Actually return the accumulated text
    return extractedText;

  } catch (const PdfError &error) {
    std::cout << "PoDoFo Error: " << error.what() << std::endl;
    return "";
  } catch (const std::exception &e) {
    std::cout << "Standard Error: " << e.what() << std::endl;
    return "";
  }
}
// Convert to JSON for Redis storage
nlohmann::json scheduleToJson(const vector<Day> &schedule) {
  nlohmann::json j;
  for (const auto &day : schedule) {
    nlohmann::json dayJson;
    dayJson["dayNumber"] = day.dayNumber;
    dayJson["courses"] = nlohmann::json::array();

    for (const auto &course : day.courses) {
      nlohmann::json courseJson;
      courseJson["courseId"] = course.courseId;
      courseJson["courseName"] = course.courseName;
      courseJson["room"] = course.room;
      courseJson["teacher"] = course.teacher;
      courseJson["timeSlot"] = course.timeSlot;
      dayJson["courses"].push_back(courseJson);
    }
    j.push_back(dayJson);
  }
  return j;
}

void printSchedule(const vector<Day> &schedule) {
  for (const auto &day : schedule) {
    cout << "=== Day " << day.dayNumber << " ===" << endl;
    cout << "Courses: " << day.courses.size() << endl;

    for (size_t i = 0; i < day.courses.size(); ++i) {
      const auto &course = day.courses[i];
      cout << "  Period " << (i + 1) << ":" << endl;
      cout << "    Course ID: " << course.courseId << endl;
      cout << "    Course: " << course.courseName << endl;
      cout << "    Room: " << course.room << endl;
      cout << "    Teacher: " << course.teacher << endl;
      cout << "    Time: " << course.timeSlot << endl;
      cout << endl;
    }
    cout << string(40, '-') << endl; // Separator line
  }
}

vector<Day> parseSchedule(const string &text) {
  enum PARSER { PERIOD, COURSEID, COURSE, ROOM, TEACHER, TIME, TIME2 };
  /*
  The vector will contain a fixed amount of 10 days and each map will have
  that days courses
  [
    {
      "CLASS": [classID, room, teacher, timeAsString],
      "AP COMPUTER SCI": [UKS21XA/71, 3W04, SMITH, 8:05- 8:46]
    }
  ]
  */
  vector<Day> parsedSchedule;
  // helper variables
  // this also signifies the row
  int periodNum = -1;
  int courseIDIdx;
  int courseIdx;
  int roomIdx;
  int teacherIdx;
  int timeIdx;
  // this also signifies the cycle day of the week (or column)
  int courseCount = -1;
  int idxRoom;
  // state based on enum
  PARSER state = PARSER::PERIOD;
  // 1 UKS21XA/71  AP COMPUTER SCI Room  3W04 SMITH  8:05- 8:46
  // repeat...UKS21XA/71 period classID course roomtext room teacher time

  array<array<Course, 10>, 10> coursesRow;

  Course currentCourse;

  // 4 ZL/4  LUNCH Room CAFE No Teacher 10:23-11:04 ZL/4
  // period classID course roomtext room teacher time
  // cout << "In parsed schedule\n";
  // Size of <<EMPTY_CELL>> plus a space
  constexpr int sizeOfEmptyCell = 14;
  for (size_t i = text.find("Day 10") + sizeOfEmptyCell + 8; i < text.length(); i++) {
    // if (i > 500) {return parsedSchedule;}
    switch (state) {
    case PARSER::PERIOD:
      // We should expect to see an empty cell
      // if (text.at(i) == '<') {
      //   i += sizeOfEmptyCell;
      //   continue;
      // }
      periodNum++;
      state = PARSER::COURSEID;
      // cout << "||||||||||||Period: " << text.at(i) << "e||||||||||||\n";
      // skip the space
      i += 2;
      courseIDIdx = i;
      break;
    case PARSER::COURSEID:
      if (text.at(i) == '<') {
        // cout << "|Day " << courseCount + 2 << "|\n";
        i += sizeOfEmptyCell;
        courseCount++;
        // cout << "FREE PERIOD\n";
        // If the edge case is that the last column has an empty course, we just
        // go to PARSER::PERIOD while skipping the empty cell
        if (courseCount == 9) {
          state = PARSER::PERIOD;
          currentCourse = Course();
          currentCourse.courseName = "Free period";
          coursesRow[periodNum][courseCount] = currentCourse;
          courseCount = 0;
        } else {
          currentCourse.courseName = "Free period";
          state = PARSER::COURSEID;
          courseIDIdx = i;
        }
        continue;
      }
      if (text.at(i) == ' ') {
        // cout << "|Day " << courseCount + 2 << "|\n";
        // cout << text.substr(courseIDIdx, i - courseIDIdx) << "e\n";
        currentCourse.courseId = removeWhitespace(text.substr(courseIDIdx, i - courseIDIdx));
        state = PARSER::COURSE;
        idxRoom = text.find("Room", i);
        courseIdx = i;
      }
      break;
    case PARSER::COURSE:
      // When parsing here, wait until you see "Room"
      // You should expect that every 10 COURSES, you will see the period number
      // which you can note
      if (i == idxRoom) {
        string course = trim(text.substr(courseIdx, i - courseIdx));
        // cout << course << "e\n";
        currentCourse.courseName = course;
        i += 5;
        roomIdx = i;
        state = PARSER::ROOM;
        courseCount++;
      }
      break;
    case PARSER::ROOM:
      if (text.at(i) == ' ') {
        // cout << text.substr(roomIdx, i - roomIdx) << "e\n";
        currentCourse.room = removeWhitespace(text.substr(roomIdx, i - roomIdx));
        i++;
        teacherIdx = i;
        state = PARSER::TEACHER;
      }
      break;
    case PARSER::TEACHER:
      // Remove whitespace, sometimes there is more or less whitespace
      if (isdigit(text.at(i))) {
        // cout << text.substr(teacherIdx, i - teacherIdx) << "e\n";
        currentCourse.teacher = trim(text.substr(teacherIdx, i - teacherIdx));
        state = PARSER::TIME;
        timeIdx = i;
      }
      break;
    case PARSER::TIME:
      // Check if you find a non-integer because that means that the course
      // name was cutoff earlier PARSER;
      if (text.at(i) == '-') {
        // Skip wierd empty spaces that sometimes happen
        if (text.at(i + 1) == ' ') {
          i++;
        }
        state = PARSER::TIME2;
      }
      break;
    case PARSER::TIME2:
      if (text.at(i) == ' ') {
        // cout << text.substr(timeIdx, i - timeIdx) << "e\n";
        currentCourse.timeSlot = removeWhitespace(text.substr(timeIdx, i - timeIdx));
        i++;
        coursesRow[periodNum][courseCount] = currentCourse;

        // cout << courseCount << '\n';

        if (courseCount == 9) {
          state = PARSER::PERIOD;
          currentCourse = Course();
          courseCount = -1;
          i += sizeOfEmptyCell;
        } else if (isdigit(
                       text.at(i + 1))) { // Check for edge case when you have a
                                          // free period on the cycle day
          // That means that we already reached the period and there is empty
          // classes in that row we need to clarify this and ask the user for
          // more information
        } else {
          state = PARSER::COURSEID;
          courseIDIdx = i;
        }
      }
      break;
    }
  }
  vector<Day> cycleDays;
  // [[Course, Course, Course],
  // [Course, Course, Course]]
  for (int c = 0; c < 10; c++) {
    Day day;
    day.dayNumber = c;
    vector<Course> courses;
    for (int r = 0; r < 10; r++) {
      courses.push_back(coursesRow[r][c]);
    }
    day.courses = courses;
    cycleDays.push_back(day);
  }
  // writeToFile("test.txt", text);
  // printSchedule(cycleDays);
  return cycleDays;
}
} // namespace PDF